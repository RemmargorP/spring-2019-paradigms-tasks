# Общее

В этом домашнем задании вам предлагается познакомиться с языком программирования Rust и многопоточностью с точки зрения прикладного программиста.
Здесь всего одна задача, которая оценивается в 5 баллов, из них 50% вы получаете за корректность и 50% за стиль.
К сожалению, мы не являемся экспертами в Rust, поэтому стиль будет проверяться относительно поверхностно.

# Задание

В папке `sudoku` лежит Cargo-проект, представляющий собой программу, перебирающую решения головоломки ["Судоку"](https://ru.wikipedia.org/wiki/%D0%A1%D1%83%D0%B4%D0%BE%D0%BA%D1%83).
Вам нужно реализовать многопоточную версию этой программы на основе выданной, используя пул потоков из крейта `threadpool` и каналы.

## Подробнее

Для выполнения задания вам необходимо выполнить инструкцию ниже:

1. Прочитайте код в файлах `sudoku/main.rs` и `sudoku/field.rs` и убедитесь, что вы понимаете, какие конструкции мы используем и общую логику решения.
   Вы также можете сгенирировать HTML-версию комментариев при помощи команды `cargo doc --document-private-items`
   (она сохранит набор HTML-файлов в папке `target/doc`).
2. Создайте в функции `main()` канал функцией `std::sync::mpsc::channel()` и вместо того,
   чтобы напрямую использовать результат `find_solution()` в `main()`, сначала запишите его
   в канал, а потом сразу прочитайте из канала.
   Это нужно, чтобы потом можно было запустить `find_solution()` в отдельном потоке и
   всё равно получить результат в `main()`.
   Изменять `find_solution()` не требуется.
   Сейчас поведение программы измениться не должно.
3. Добавьте в `Cargo.toml` зависимость [`threadpool`](https://docs.rs/threadpool/1.7.1/threadpool/)) и подключите этот внеший модуль в `main.rs`
   при помощи команды `extern crate`.
4. Создайте в `main()` пул из 8 рабочих потоков.
5. Запустите функцию `find_solution()` как одну задачу в пуле потоков.
   Убедитесь, что поведение и скорость работы программы не изменились.
   Убедитесь, что загружается только одно ядро процессора.
6. Для распараллеливания напишите отдельную функция `spawn_tasks()` и вызовите её в `main()` вместо запуска `find_solution()`
   В первой версии она переберёт значения одной из клеток поля при помощи `try_extend_field()` и
   отправит в пул потоков от 0 до 9 задач (по одной на каждое значение клетки, которое не приводит к противоречию).
   * Каждая задача — это запуск функции `find_solution()` на частично заполненном поле.
   * Параметры `spawn_tasks()` остаются на ваше усмотрение, однако ей точно потребуется пул потоков и конец канала, в который необходимо записать ответ.
   * Обратите особое внимание на время жизни аргументов этой функции.
7. Убедитесь, что поведение программы не изменилось.
   Скорость работы в этот момент могла незначительно увеличиться.
   Убедитесь, что хотя бы в начале программы загружается больше одного ядра процессора.
8. Создавать 9 задач на 8 потоков — не самая хорошая идея, потому что
   если одна задача выполнится сильно быстрее другой, потоки начнут простаивать.
   Поэтому перед созданием задачи вам требуется перебрать значения не одной клетки поля,
   а `DEPTH` клеток поля.
   Добавьте константу `DEPTH: i32 = 1` и измените `spawn_tasks()` так, чтобы она
   рекурсивно перебирала значения первых `DEPTH` клеток и запускала отдельную задачу
   только после этого.
9. Убедитесь, что поведение и скорость работы программы не изменились.
10. Измените `DEPTH` с 1 на 2.
    Убедитесь, что поведение программы не изменилось,
    а скорость выросла и загрузка процессора стала больше.

# Тесты

В представленной реализации уже имеется несколько автоматических тестов.
Вам не требуется добавлять свои собственные, однако требуется не сломать имеющиеся.

# Требования к корректности решения

Если присланные файлы не соответствуют хотя бы одному из условий ниже, решение считается некорректным и оценивается в 0 баллов:

* Строгость предупреждений и диагностик в `cargo.toml` не понижена
* Отсутствуют атрибуты `#![rustfmt::skip]` и подобное заглушение автопроверки
* Если `rustfmt.toml` изменён, то это происходит в самом первом коммите одновременно с автоматическим переформатированием предоставленного кода
* Все проверки на Travis проходят:
  * `cargo build` должен собирать исполняемый файл без ошибок и предупреждений
  * `cargo test` отрабатывает без ошибок
  * Файлы не изменяются при форматировании [rustfmt](https://github.com/rust-lang/rustfmt)

# Формат сдачи
Если возникают **любые** непонятки с форматом сдачи (даже простые и мелкие) - пишите преподавателю!
Мы не хотим, чтобы вы не сдали просто потому что кто-то не очень хорошо рассказал Git или дал мало практики :)

* Для сдачи домашнего задания откройте pull request в ветку `master` нашего репозитория
* Pull request должен удовлетворять следующим требованиям, иначе он не будет проверен:
  * Название: `Task08, GroupXX, Фамилия Имя`
    * Например, `Task08, Group09, Суворов Егор`
    * Не допускаются сокращения, перестановка слов, отсутствие запятой, пробелов или написание имени транслитом
  * Отсутствуют merge conflicts
  * В сумме за все коммиты (вкладка "Files Changed") отсутствуют временные файлы вроде `.*.swp`, настройки среды вроде `.idea` и прочий мусор.
    Разрешается добавлять новые файлы только если это требуется заданием.
    * Если вам хочется добавить `.gitignore`, добавьте его [конкретно на вашем компьютере](https://help.github.com/en/articles/ignoring-files#create-a-global-gitignore)
      при помощи `git config --global core.excludesfile` или [конкретно в вашем клоне](https://help.github.com/en/articles/ignoring-files#explicit-repository-excludes)
      через файл `.git/info/exclude`
  * Ни в одном из коммитов не смешаны изменения, относящиеся к разным задачам
  * В описании pull request упомянут ваш преподаватель:
    для `18.Б09-пу` — `@yeputons`, для `18.Б10-пу` — `@edgarzhavoronkov`
* В каждый момент времени может быть открыто не более одного pull request
* Вопросы следует задавать либо по почте, либо открыв Issue в репозитории в произвольной форме и с названием содержащим вопрос, начинающимся с `Task 08:`
* Для сдачи задания отправлять письмо не требуется, достаточно открытия Pull Request по установленной форме
* Для проверки преподаватель назначает себя reviewer и отправляет вам review прямо на GitHub
  * Approved означает полное засчитывание упомянутых в pull request задач по корректности и стилю
  * Changes requested означает, что что-то надо доделать (при этом могут быть уже зачтены какие-то задачи или может быть зачтена корректность)
* Если вам захотелось исправить решение после прохождения review, вам требуется:
  * Добавить один или более коммитов с исправлениями
    * При этом запрещается переписывать историю, которую уже видел преподаватель на момент проверки, если только это не было обговорено в явном виде
    * В процессе исправлений вы можете переписывать историю добавленных коммитов (которые преподаватель ещё не видел)
  * Оставить в pull request комментарий `исправлено` с упоминанием вашего преподавателя.
    Например: `@yeputons, исправлено`.
    До появления комментария считается, что вы в процессе исправления, и pull request не проверяется
* Если вам захотелось исправить решение до прохождения review, но после открытия pull request или после комментария `исправлено`,
  требования такие же: добавляете новые коммиты, старые не переписываете, в конце оставляете ещё один комментарий
* После вердикта `Approved` или прохождения жёсткого дедлайна pull request закрывается.

# Сроки сдачи
|   | `18.Б09-пу` | `18.Б10-пу` |Максимальное количество баллов при сдаче в срок
|---|---|---|---|
|Дата выдачи|12.04.2019|12.04.2019||
|Мягкий дедлайн|21.04.2019 22:59|21.04.2019 22:59|5|
|Жёсткий дедлайн|28.04.2019 22:59|28.04.2019 22:59|2.5|
